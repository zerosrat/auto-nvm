use anyhow::{anyhow, Context, Result};
use std::fs;
use std::path::{Path, PathBuf};
use crate::nvm::ShellType;

/// Marker strings for identifying auto-nvm configuration in config files
const AUTO_NVM_START: &str = "# === AUTO-NVM START ===";
const AUTO_NVM_END: &str = "# === AUTO-NVM END ===";

/// Shell integration scripts (embedded at compile time)
const BASH_INTEGRATION: &str = include_str!("../../shell-integration/bash/auto-nvm.bash");
const ZSH_INTEGRATION: &str = include_str!("../../shell-integration/zsh/auto-nvm.zsh");
const FISH_INTEGRATION: &str = include_str!("../../shell-integration/fish/auto-nvm.fish");
const POWERSHELL_INTEGRATION: &str = include_str!("../../shell-integration/powershell/auto-nvm.psm1");

/// Get the configuration file path for the given shell type
pub fn get_config_file_path(shell: ShellType) -> Result<PathBuf> {
    let home_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not determine home directory"))?;

    match shell {
        ShellType::Bash => {
            // Prefer .bashrc, fall back to .bash_profile
            let bashrc = home_dir.join(".bashrc");
            if bashrc.exists() {
                Ok(bashrc)
            } else {
                Ok(home_dir.join(".bash_profile"))
            }
        }
        ShellType::Zsh => {
            Ok(home_dir.join(".zshrc"))
        }
        ShellType::Fish => {
            let config_dir = home_dir.join(".config/fish");
            Ok(config_dir.join("config.fish"))
        }
        ShellType::PowerShell => {
            // On Windows, get PowerShell profile path
            if cfg!(windows) {
                // Try to get the profile path via PowerShell
                let output = std::process::Command::new("powershell")
                    .args(["-Command", "echo $PROFILE"])
                    .output();
                match output {
                    Ok(result) if result.status.success() => {
                        let path = String::from_utf8_lossy(&result.stdout).trim().to_string();
                        Ok(PathBuf::from(path))
                    }
                    _ => Err(anyhow!("Could not determine PowerShell profile path")),
                }
            } else {
                // On Unix, PowerShell profile is in home directory
                Ok(home_dir.join(".config/powershell/Microsoft.PowerShell_profile.ps1"))
            }
        }
    }
}

/// Wrap shell integration content with auto-nvm markers and generation comment
fn wrap_with_markers(content: &str) -> String {
    format!(
        "{}\n# Auto-generated by auto-nvm setup\n# To remove, run: auto-nvm uninstall\n# Or manually delete lines between START and END markers\n\n{}\n\n{}",
        AUTO_NVM_START,
        content.trim(),
        AUTO_NVM_END
    )
}

/// Generate the shell integration script for the given shell type
pub fn generate_integration_script(shell: ShellType) -> String {
    let content = match shell {
        ShellType::Bash => BASH_INTEGRATION,
        ShellType::Zsh => ZSH_INTEGRATION,
        ShellType::Fish => FISH_INTEGRATION,
        ShellType::PowerShell => POWERSHELL_INTEGRATION,
    };

    wrap_with_markers(content)
}

/// Check if auto-nvm is already configured in the given config file
pub fn check_already_configured(config_path: &Path) -> bool {
    if !config_path.exists() {
        return false;
    }

    match fs::read_to_string(config_path) {
        Ok(content) => content.contains(AUTO_NVM_START),
        Err(_) => false,
    }
}

/// Backup the configuration file with a .backup extension
pub fn backup_config_file(config_path: &Path) -> Result<PathBuf> {
    if !config_path.exists() {
        return Ok(config_path.to_path_buf());
    }

    let backup_path = config_path.with_extension("backup");

    fs::copy(config_path, &backup_path)
        .with_context(|| format!("Failed to create backup at {}", backup_path.display()))?;

    Ok(backup_path)
}

/// Append the integration script to the configuration file
pub fn append_to_config_file(config_path: &Path, script: &str) -> Result<()> {
    // Create parent directories if they don't exist
    if let Some(parent) = config_path.parent() {
        fs::create_dir_all(parent)
            .with_context(|| format!("Failed to create directory {}", parent.display()))?;
    }

    // Append the script to the config file
    let mut file = fs::OpenOptions::new()
        .create(true)
        .append(true)
        .open(config_path)
        .with_context(|| format!("Failed to open config file {}", config_path.display()))?;

    use std::io::Write;
    writeln!(file, "\n{}", script)
        .context("Failed to write to config file")?;

    Ok(())
}

/// Remove auto-nvm configuration from the config file
/// Returns true if configuration was found and removed, false otherwise
pub fn remove_integration_from_config(config_path: &Path) -> Result<bool> {
    if !config_path.exists() {
        return Ok(false);
    }

    let content = fs::read_to_string(config_path)
        .context("Failed to read config file")?;

    if !content.contains(AUTO_NVM_START) || !content.contains(AUTO_NVM_END) {
        return Ok(false);
    }

    // Find and remove the auto-nvm configuration block
    let mut result = String::new();
    let mut in_auto_nvm_block = false;
    let mut lines_removed = 0;

    for line in content.lines() {
        if line.contains(AUTO_NVM_START) {
            in_auto_nvm_block = true;
            continue;
        }

        if in_auto_nvm_block {
            lines_removed += 1;
            if line.contains(AUTO_NVM_END) {
                in_auto_nvm_block = false;
                // Remove the newline before the START marker too
                if let Some(last_char) = result.chars().last() {
                    if last_char == '\n' {
                        result.pop();
                        if let Some(last_char) = result.chars().last() {
                            if last_char == '\r' {
                                result.pop();
                            }
                        }
                    }
                }
            }
            continue;
        }

        result.push_str(line);
        result.push('\n');
    }

    // Write the cleaned content back
    fs::write(config_path, result.trim_end())
        .context("Failed to write cleaned config file")?;

    Ok(lines_removed > 0)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::NamedTempFile;

    #[test]
    fn test_generate_integration_script_bash() {
        let script = generate_integration_script(ShellType::Bash);
        assert!(script.contains(AUTO_NVM_START));
        assert!(script.contains(AUTO_NVM_END));
        assert!(script.contains("cd()"));
    }

    #[test]
    fn test_generate_integration_script_zsh() {
        let script = generate_integration_script(ShellType::Zsh);
        assert!(script.contains(AUTO_NVM_START));
        assert!(script.contains(AUTO_NVM_END));
        assert!(script.contains("cd()"));
    }

    #[test]
    fn test_generate_integration_script_fish() {
        let script = generate_integration_script(ShellType::Fish);
        assert!(script.contains(AUTO_NVM_START));
        assert!(script.contains(AUTO_NVM_END));
        assert!(script.contains("function cd"));
    }

    #[test]
    fn test_generate_integration_script_powershell() {
        let script = generate_integration_script(ShellType::PowerShell);
        assert!(script.contains(AUTO_NVM_START));
        assert!(script.contains(AUTO_NVM_END));
        assert!(script.contains("function Set-Location"));
    }

    #[test]
    fn test_check_already_configured() {
        let temp_file = NamedTempFile::new().unwrap();
        let path = temp_file.path();

        // Not configured initially
        assert!(!check_already_configured(path));

        // Add configuration
        let script = generate_integration_script(ShellType::Bash);
        fs::write(path, script).unwrap();

        // Now configured
        assert!(check_already_configured(path));
    }

    #[test]
    fn test_remove_integration_from_config() {
        let temp_file = NamedTempFile::new().unwrap();
        let path = temp_file.path();

        // Write some content with auto-nvm configuration
        let content = r#"# My config
export PATH="$HOME/bin:$PATH"

# === AUTO-NVM START ===
# Auto-generated by auto-nvm setup
# To remove, run: auto-nvm uninstall
# Or manually delete lines between START and END markers

cd() {
    builtin cd "$@" || return
    eval "$(auto-nvm switch)"
}

# === AUTO-NVM END ===

# More config
alias ll='ls -la'
"#;
        fs::write(path, content).unwrap();

        // Remove the configuration
        let removed = remove_integration_from_config(path).unwrap();
        assert!(removed);

        // Verify the result
        let result = fs::read_to_string(path).unwrap();
        assert!(!result.contains(AUTO_NVM_START));
        assert!(!result.contains(AUTO_NVM_END));
        assert!(result.contains("# My config"));
        assert!(result.contains("alias ll='ls -la'"));
    }

    #[test]
    fn test_remove_integration_not_configured() {
        let temp_file = NamedTempFile::new().unwrap();
        let path = temp_file.path();

        // Write some content without auto-nvm configuration
        let content = r#"# My config
export PATH="$HOME/bin:$PATH"
alias ll='ls -la'
"#;
        fs::write(path, content).unwrap();

        // Try to remove - should return false
        let removed = remove_integration_from_config(path).unwrap();
        assert!(!removed);

        // Content should be unchanged
        let result = fs::read_to_string(path).unwrap();
        assert_eq!(result, content);
    }
}
